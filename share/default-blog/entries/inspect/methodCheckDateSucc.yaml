--- !hobix.com,2004/entry 
title: "Method Check: Date#succ"
author: why
created: 2005-03-24 12:44:12.066317 -05:00
content: >-
  @Date#succ@ has saved the day for me in calendaring operations.  I was Duck
  Hunting and simply guessed it was there.  (Someone should put together a Duck
  Typer's Handbook that just contains the commonly reused method names and their
  presumed meanings.)


  Basically, I want to rave about Ruby's @Date@ class, autonomous from @Time@.  I
  had a table of rows which represented individual dates.  I needed to take that
  table and build date ranges.


  I'll simplify by posing the problem as an event calendar.


  <pre>
   events = {}
   sqlq = "SELECT title, event_date FROM events ORDER BY event_date ASC"
   db.query( sqlq ).each_hash do |event|
     date_e = Date.new( *event['event_date'].split('-').map { |n| n.to_i } )
     events[event['title']] ||= []
     last_e = events[event['title']].last
     if last_e
       if last_e[1].succ == date_e
         last_e[1] += 1
         next
       end
     end
     events[event['title']] << [date_e] * 2
   end
  </pre>


  I'll draw your attention to two lines.  The @last_e[1].succ@ and the @last_e[1]
  += 1@ lines.  I'm building a Date range with a start and end date.  So,
  @last_e[1]@ represents the end date.


  The line @last_e[1].succ == date_e@ compares the _day after_ the end date with
  the date from the database.  If they match, then we know the date is the next
  date in the series.


  The following line, @last_e[1] += 1@ adds a single day to the end date.  Date
  math works really nicely like that.  (Now, I'll ask you how you prefer to add
  months and years.)


  And, even better, @Date@ objects inside of a @Range@.


  <pre>
   >> require 'date'
   >> D = proc { |*d| Date.new(*d) }
   >> (D[2004, 1, 1]..D[2004, 1, 12]).include? D[2004, 5, 6]
   => false
   >> (D[2004, 1, 1]..D[2004, 1, 12]).include? D[2004, 1, 6]
   => true
  </pre>
